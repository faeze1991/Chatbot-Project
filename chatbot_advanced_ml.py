# -*- coding: utf-8 -*-
"""chatbot_Advanced_ML.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BYlZJRJDPQRLrD8bgp3v5OUyiP5u5Wbb
"""

pip install requests streamlit rdflib SPARQLWrapper

pip install requests

import requests
import json

#API Credentials
GWDG_API_KEY = "8375644df757be6bd358b8fe9daad3dc"
GWDG_API_URL = "https://chat-ai.academiccloud.de/v1/chat/completions"  ###adding completions at the end of the endpoint that I received to read text
GWDG_MODEL = "meta-llama-3.1-8b-instruct"
DBPEDIA_SPARQL_ENDPOINT = "https://dbpedia.org/sparql"

##################Load LC-QuAD Dataset
def load_lcquad(file_path):
    """Loads LC-QuAD dataset containing predefined SPARQL queries."""
    try:
        with open(file_path, "r", encoding="utf-8") as file:
            data = json.load(file)
            print(f"Loaded {len(data)} questions from LC-QUAD!")
            return data
    except FileNotFoundError:
        print("Warning: Dataset file not found.")
        return []

########################Check LC-QuAD for a predefined query
def check_lcquad(question, lcquad_data):
    """Check if the question exists in the LC-QUAD dataset."""
    for item in lcquad_data:
        if item.get("corrected_question", "").lower() == question.lower():
            return item["sparql_query"]
    return None

##################defining the SPARQL Query
def generate_sparql_query(question):
    """Generates a SPARQL query using the LLaMA API."""
    headers = {
        "Authorization": f"Bearer {GWDG_API_KEY}",
        "Content-Type": "application/json"
    }

    system_prompt = """
    Generate a valid SPARQL query for DBpedia to answer the given question.
    Ensure the following:
    1. Use `dbo:` ontology whenever possible.
    2. Use `rdfs:label` to extract human-readable values.
    3. If querying a person's birth date, use `dbo:birthDate`.
    4. If querying a person's occupation, use `dbo:occupation`.
    5. If querying a location, use `dbo:location`.
    6. If querying a city, use `dbo:country` or `dbo:isPartOf`.
    7. Ensure all URIs are formatted as <http://dbpedia.org/resource/...>.
    8. Include `OPTIONAL { ?location rdfs:label ?locationLabel }` to retrieve readable names.
    9. Return only the valid SPARQL query, with no additional text.
    """

    data = {
        "model": GWDG_MODEL,
        "messages": [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": question}
        ],
        "temperature": 0.3,
        "max_tokens": 300
    }

    response = requests.post(GWDG_API_URL, json=data, headers=headers)

    if response.status_code == 200:
        try:
            result = response.json()
            sparql_query = result["choices"][0]["message"]["content"].strip()
            # Ensure the query starts with PREFIX and SELECT to be valid
            if "PREFIX" in sparql_query and "SELECT" in sparql_query:
                return sparql_query
        except json.JSONDecodeError:
            return None
    return None

####################################SPARQL Query
def execute_sparql_query(sparql_query):
    """Executes a SPARQL query on DBpedia and extracts results."""
    params = {"query": sparql_query.strip(), "format": "json"}
    response = requests.get(DBPEDIA_SPARQL_ENDPOINT, params=params)

    if response.status_code == 200:
        try:
            results = response.json().get("results", {}).get("bindings", [])
            if results:
                extracted_values = set()  # Use a set to remove duplicates
                for result in results:
                    # Extract readable labels when available
                    if "locationLabel" in result:
                        extracted_values.add(result["locationLabel"].get("value", "No answer found"))
                    elif "countryLabel" in result:
                        extracted_values.add(result["countryLabel"].get("value", "No answer found"))
                    elif "location" in result:
                        extracted_values.add(result["location"].get("value", "No answer found"))

                # Ensure a single concise response
                return next(iter(extracted_values), "No results found.")
            return "No results found."
        except json.JSONDecodeError:
            return "JSON decoding error."
    return "SPARQL query failed."

############################################checking for answers
def chatbot_response(question, lcquad_data):
    """Processes a question: checks LC-QUAD first, then queries API if needed."""
    sparql_query = check_lcquad(question, lcquad_data)

    if not sparql_query:
        sparql_query = generate_sparql_query(question)

    if not sparql_query:
        return "No valid SPARQL query found."

    return execute_sparql_query(sparql_query)

# run the chatbot:
if __name__ == "__main__":
    lcquad_data = load_lcquad("/content/sample_data/test-data.json")

    while True:
        question = input("Ask a question (or type 'exit' to quit): ")
        if question.lower() == "exit":
            break

        answer = chatbot_response(question, lcquad_data)
        print(f"Answer: {answer}")

